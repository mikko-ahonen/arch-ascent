<div id="scope-graph-container">
    <div class="d-flex justify-content-between align-items-center p-2 border-bottom">
        <div class="d-flex gap-2">
            <div class="btn-group btn-group-sm">
                <button id="scope-toggle-labels-btn" class="btn btn-outline-secondary btn-sm" onclick="scopeGraphToggleLabels()">Labels</button>
                <button id="scope-toggle-edges-btn" class="btn btn-outline-secondary btn-sm active" onclick="scopeGraphToggleEdges()">Edges</button>
                <button id="scope-toggle-transitive-btn" class="btn btn-outline-secondary btn-sm" onclick="scopeGraphToggleTransitive()">Transitive</button>
                <div class="btn-group">
                    <button id="scope-toggle-cycles-btn" class="btn btn-outline-secondary btn-sm" onclick="scopeGraphToggleCycles()">Cycles</button>
                    <button type="button" class="btn btn-outline-secondary btn-sm dropdown-toggle dropdown-toggle-split" data-bs-toggle="dropdown" aria-expanded="false" id="scope-cycles-dropdown-btn" style="display: none;">
                        <span class="visually-hidden">Toggle Dropdown</span>
                    </button>
                    <ul class="dropdown-menu dropdown-menu-end" id="scope-cycles-list" style="max-height: 300px; overflow-y: auto;">
                    </ul>
                </div>
                <button class="btn btn-outline-secondary btn-sm" onclick="scopeGraphFit()">Fit</button>
                <button class="btn btn-outline-secondary btn-sm" onclick="scopeGraphRelayout()">Relayout</button>
            </div>
            <div class="dropdown">
                <button class="btn btn-outline-secondary btn-sm dropdown-toggle" type="button" id="highlightDropdown" data-bs-toggle="dropdown" aria-expanded="false">
                    Highlight...
                </button>
                <ul class="dropdown-menu" aria-labelledby="highlightDropdown">
                    <li><a class="dropdown-item" href="#" onclick="openHighlightModal('degree'); return false;">By Degree <small class="text-muted">(direct links)</small></a></li>
                    <li><a class="dropdown-item" href="#" onclick="openHighlightModal('betweenness'); return false;">By Betweenness <small class="text-muted">(bridge between others)</small></a></li>
                    <li><a class="dropdown-item" href="#" onclick="openHighlightModal('closeness'); return false;">By Closeness <small class="text-muted">(average distance to all)</small></a></li>
                    <li><a class="dropdown-item" href="#" onclick="openHighlightModal('eigenvector'); return false;">By Eigenvector <small class="text-muted">(influence via important neighbours)</small></a></li>
                    <li><hr class="dropdown-divider"></li>
                    <li><a class="dropdown-item" href="#" onclick="clearHighlight(); return false;">Clear highlight</a></li>
                </ul>
            </div>
        </div>
        <small class="text-muted"><span id="scope-graph-count">0</span> nodes</small>
    </div>
    <div id="scope-cy-wrapper" style="height: {{ height }}; width: 100%; position: relative;">
        <div id="scope-cy" style="height: 100%; width: 100%;"></div>
        <div id="scope-loading-overlay" style="display: none; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); z-index: 100; align-items: center; justify-content: center;">
            <div class="text-center text-white">
                <div class="spinner-border mb-2" role="status"></div>
                <div id="scope-loading-text">Loading graph...</div>
            </div>
        </div>
    </div>
    <div id="scope-cy-tooltip" class="position-absolute bg-dark text-white px-2 py-1 rounded small" style="display: none; pointer-events: none; z-index: 1000;"></div>
</div>

<!-- Highlight Threshold Modal -->
<div class="modal fade" id="highlightModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="highlightModalLabel">Highlight by Centrality</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <p id="highlightDescription" class="text-muted small mb-3"></p>
                <div class="mb-3">
                    <label for="highlightThreshold" class="form-label">Threshold (percentile)</label>
                    <input type="range" class="form-range" id="highlightThreshold" min="0" max="100" value="75" oninput="updateThresholdDisplay()">
                    <div class="d-flex justify-content-between">
                        <small class="text-muted">0%</small>
                        <small id="thresholdValue" class="fw-bold">75%</small>
                        <small class="text-muted">100%</small>
                    </div>
                </div>
                <div class="alert alert-info small py-2" id="highlightPreview">
                    <span id="highlightPreviewCount">0</span> nodes will be highlighted
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" onclick="applyHighlight()">Apply</button>
            </div>
        </div>
    </div>
</div>

<script src="https://unpkg.com/cytoscape@3.30.4/dist/cytoscape.min.js"></script>
<script>
(function() {
    let scopeLabelsVisible = false;  // Default off for performance
    let scopeEdgesVisible = true;  // Edges on by default, but hidden for very large graphs
    let scopeTransitiveVisible = false;  // Default off for cleaner view
    let scopeCyclesVisible = false;
    let scopeCy = null;
    let currentCycles = [];  // List of cycles from backend
    let shownCycleIndex = -1;  // Currently shown individual cycle
    let cyclesLoaded = false;  // Track if cycles have been fetched
    let currentVisibleKeys = [];  // Track current keys for lazy loading
    let deferredEdges = null;  // Store edges for lazy loading on very large graphs
    let edgesDeferred = false;  // Track if edges were deferred

    // Highlight state
    let currentHighlightMetric = null;
    let currentHighlightThreshold = 75;
    let highlightedNodeKeys = new Set();
    let nodeCentralities = {};

    // Get CSRF token from cookie or hidden input
    function getCSRFToken() {
        // First try the hidden input field
        const input = document.querySelector('[name=csrfmiddlewaretoken]');
        if (input) return input.value;

        // Fallback to cookie
        const name = 'csrftoken';
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }

    function initScopeGraph() {
        const container = document.getElementById('scope-cy');
        if (!container) return;

        scopeCy = cytoscape({
            container: container,
            elements: [],
            style: [
                {
                    selector: 'node',
                    style: {
                        'background-color': '#0d6efd',
                        'label': '',  // Labels off by default for performance
                        'color': '#e0e0e0',
                        'text-outline-color': '#1a1a1a',
                        'text-outline-width': 2,
                        'text-valign': 'bottom',
                        'text-margin-y': 5,
                        'font-size': '11px',
                        'width': 30,
                        'height': 30,
                    }
                },
                {
                    selector: 'node:selected',
                    style: {
                        'background-color': '#198754',
                        'border-width': 3,
                        'border-color': '#333',
                    }
                },
                {
                    selector: 'edge',
                    style: {
                        'width': 1.5,
                        'line-color': '#6c757d',
                        'target-arrow-color': '#6c757d',
                        'target-arrow-shape': 'triangle',
                        'curve-style': 'bezier',
                    }
                },
                {
                    selector: 'edge[?transitive]',
                    style: {
                        'line-style': 'dashed',
                        'line-color': '#adb5bd',
                        'target-arrow-color': '#adb5bd',
                        'opacity': 0.6,
                    }
                },
                {
                    selector: 'edge.cycle-highlighted',
                    style: {
                        'line-color': '#dc3545',
                        'target-arrow-color': '#dc3545',
                        'width': 2,
                        'opacity': 1,
                    }
                },
                {
                    selector: 'node.cycle-highlighted',
                    style: {
                        'border-width': 2,
                        'border-color': '#dc3545',
                    }
                },
                {
                    selector: 'edge.single-cycle-highlighted',
                    style: {
                        'line-color': '#fd7e14',
                        'target-arrow-color': '#fd7e14',
                        'width': 3,
                        'opacity': 1,
                        'z-index': 999,
                    }
                },
                {
                    selector: 'node.single-cycle-highlighted',
                    style: {
                        'background-color': '#fd7e14',
                        'border-width': 3,
                        'border-color': '#dc3545',
                        'z-index': 999,
                    }
                },
                {
                    selector: 'node.centrality-highlighted',
                    style: {
                        'background-color': '#ffc107',
                        'border-width': 3,
                        'border-color': '#ff9800',
                    }
                }
            ],
            layout: { name: 'preset' },
            minZoom: 0.2,
            maxZoom: 3,
        });

        // Handle selection changes - sync back to list view
        scopeCy.on('select unselect', 'node', function() {
            const selectedKeys = scopeCy.nodes(':selected').map(n => n.id());
            window.dispatchEvent(new CustomEvent('scope-graph-selection', {
                detail: { selectedKeys }
            }));
        });

        // Tooltip on hover
        const tooltip = document.getElementById('scope-cy-tooltip');
        const cyContainer = document.getElementById('scope-cy');

        scopeCy.on('mouseover', 'node', function(e) {
            if (!scopeLabelsVisible) {
                tooltip.textContent = e.target.data('label');
                tooltip.style.display = 'block';
            }
        });

        scopeCy.on('mousemove', 'node', function(e) {
            if (!scopeLabelsVisible) {
                const pos = e.renderedPosition;
                tooltip.style.left = (pos.x + 15) + 'px';
                tooltip.style.top = (pos.y - 10) + 'px';
            }
        });

        scopeCy.on('mouseout', 'node', function() {
            tooltip.style.display = 'none';
        });

        window.scopeGraph = scopeCy;
    }

    // Centrality calculation functions
    const centralityDescriptions = {
        degree: 'Degree centrality counts the number of direct connections (edges) a node has. Nodes with high degree are well-connected hubs.',
        betweenness: 'Betweenness centrality measures how often a node lies on the shortest path between other nodes. High betweenness nodes act as bridges.',
        closeness: 'Closeness centrality measures how close a node is to all other nodes (average shortest path distance). High closeness nodes can reach others quickly.',
        eigenvector: 'Eigenvector centrality measures influence based on connections to other important nodes. High eigenvector nodes are connected to other influential nodes.'
    };

    function calculateDegreeCentrality() {
        if (!scopeCy) return {};
        const centralities = {};
        scopeCy.nodes().forEach(node => {
            centralities[node.id()] = node.degree(false); // false = don't include loops
        });
        return centralities;
    }

    function calculateBetweennessCentrality() {
        if (!scopeCy) return {};
        const centralities = {};
        const nodes = scopeCy.nodes();
        const n = nodes.length;

        // Initialize
        nodes.forEach(node => {
            centralities[node.id()] = 0;
        });

        // Brandes algorithm for betweenness
        nodes.forEach(source => {
            const stack = [];
            const predecessors = {};
            const sigma = {};
            const dist = {};

            nodes.forEach(v => {
                predecessors[v.id()] = [];
                sigma[v.id()] = 0;
                dist[v.id()] = -1;
            });

            sigma[source.id()] = 1;
            dist[source.id()] = 0;

            const queue = [source];
            while (queue.length > 0) {
                const v = queue.shift();
                stack.push(v);

                v.neighborhood('node').forEach(w => {
                    // First visit?
                    if (dist[w.id()] < 0) {
                        queue.push(w);
                        dist[w.id()] = dist[v.id()] + 1;
                    }
                    // Shortest path to w via v?
                    if (dist[w.id()] === dist[v.id()] + 1) {
                        sigma[w.id()] += sigma[v.id()];
                        predecessors[w.id()].push(v);
                    }
                });
            }

            const delta = {};
            nodes.forEach(v => {
                delta[v.id()] = 0;
            });

            while (stack.length > 0) {
                const w = stack.pop();
                predecessors[w.id()].forEach(v => {
                    delta[v.id()] += (sigma[v.id()] / sigma[w.id()]) * (1 + delta[w.id()]);
                });
                if (w.id() !== source.id()) {
                    centralities[w.id()] += delta[w.id()];
                }
            }
        });

        // Normalize (undirected graph)
        const factor = n > 2 ? 2 / ((n - 1) * (n - 2)) : 1;
        Object.keys(centralities).forEach(id => {
            centralities[id] *= factor;
        });

        return centralities;
    }

    function calculateClosenessCentrality() {
        if (!scopeCy) return {};
        const centralities = {};
        const nodes = scopeCy.nodes();
        const n = nodes.length;

        nodes.forEach(source => {
            // BFS to find shortest paths
            const dist = {};
            nodes.forEach(v => {
                dist[v.id()] = Infinity;
            });
            dist[source.id()] = 0;

            const queue = [source];
            while (queue.length > 0) {
                const v = queue.shift();
                v.neighborhood('node').forEach(w => {
                    if (dist[w.id()] === Infinity) {
                        dist[w.id()] = dist[v.id()] + 1;
                        queue.push(w);
                    }
                });
            }

            // Sum of distances
            let totalDist = 0;
            let reachable = 0;
            Object.values(dist).forEach(d => {
                if (d !== Infinity && d > 0) {
                    totalDist += d;
                    reachable++;
                }
            });

            // Closeness = (n-1) / sum of distances (normalized)
            centralities[source.id()] = reachable > 0 ? reachable / totalDist : 0;
        });

        return centralities;
    }

    function calculateEigenvectorCentrality() {
        if (!scopeCy) return {};
        const centralities = {};
        const nodes = scopeCy.nodes();
        const n = nodes.length;

        if (n === 0) return {};

        // Power iteration method
        const maxIterations = 100;
        const tolerance = 1e-6;

        // Initialize with uniform values
        nodes.forEach(node => {
            centralities[node.id()] = 1 / n;
        });

        for (let iter = 0; iter < maxIterations; iter++) {
            const newCentralities = {};
            let norm = 0;

            nodes.forEach(node => {
                let sum = 0;
                node.neighborhood('node').forEach(neighbor => {
                    sum += centralities[neighbor.id()];
                });
                newCentralities[node.id()] = sum;
                norm += sum * sum;
            });

            // Normalize
            norm = Math.sqrt(norm);
            if (norm === 0) norm = 1;

            let diff = 0;
            Object.keys(newCentralities).forEach(id => {
                newCentralities[id] /= norm;
                diff += Math.abs(newCentralities[id] - centralities[id]);
                centralities[id] = newCentralities[id];
            });

            if (diff < tolerance) break;
        }

        return centralities;
    }

    function calculateCentrality(metric) {
        switch (metric) {
            case 'degree': return calculateDegreeCentrality();
            case 'betweenness': return calculateBetweennessCentrality();
            case 'closeness': return calculateClosenessCentrality();
            case 'eigenvector': return calculateEigenvectorCentrality();
            default: return {};
        }
    }

    function getNodesAboveThreshold(centralities, percentile) {
        const values = Object.values(centralities).sort((a, b) => a - b);
        if (values.length === 0) return [];

        const thresholdIndex = Math.floor((percentile / 100) * values.length);
        const thresholdValue = values[Math.min(thresholdIndex, values.length - 1)];

        return Object.entries(centralities)
            .filter(([id, value]) => value >= thresholdValue)
            .map(([id]) => id);
    }

    // Modal handling functions
    window.openHighlightModal = function(metric) {
        if (!scopeCy || scopeCy.nodes().length === 0) {
            alert('No nodes in the graph to highlight.');
            return;
        }

        currentHighlightMetric = metric;
        document.getElementById('highlightModalLabel').textContent = 'Highlight by ' + metric.charAt(0).toUpperCase() + metric.slice(1);
        document.getElementById('highlightDescription').textContent = centralityDescriptions[metric];
        document.getElementById('highlightThreshold').value = currentHighlightThreshold;
        document.getElementById('thresholdValue').textContent = currentHighlightThreshold + '%';

        // Calculate centralities and update preview
        nodeCentralities = calculateCentrality(metric);
        updateHighlightPreview();

        new bootstrap.Modal(document.getElementById('highlightModal')).show();
    };

    window.updateThresholdDisplay = function() {
        const threshold = parseInt(document.getElementById('highlightThreshold').value);
        document.getElementById('thresholdValue').textContent = threshold + '%';
        currentHighlightThreshold = threshold;
        updateHighlightPreview();
    };

    function updateHighlightPreview() {
        const nodes = getNodesAboveThreshold(nodeCentralities, currentHighlightThreshold);
        document.getElementById('highlightPreviewCount').textContent = nodes.length;
    }

    window.applyHighlight = function() {
        const nodes = getNodesAboveThreshold(nodeCentralities, currentHighlightThreshold);
        highlightedNodeKeys = new Set(nodes);

        // Apply highlight class to nodes in graph
        if (scopeCy) {
            scopeCy.nodes().removeClass('centrality-highlighted');
            nodes.forEach(nodeId => {
                const node = scopeCy.getElementById(nodeId);
                if (node && node.length > 0) {
                    node.addClass('centrality-highlighted');
                }
            });
        }

        // Dispatch event to sync with list view
        window.dispatchEvent(new CustomEvent('centrality-highlight-changed', {
            detail: {
                highlightedKeys: Array.from(highlightedNodeKeys),
                metric: currentHighlightMetric,
                threshold: currentHighlightThreshold
            }
        }));

        // Update dropdown button to show active state
        const btn = document.getElementById('highlightDropdown');
        if (highlightedNodeKeys.size > 0) {
            btn.classList.remove('btn-outline-secondary');
            btn.classList.add('btn-warning');
            btn.textContent = 'Highlighted: ' + highlightedNodeKeys.size;
        }

        bootstrap.Modal.getInstance(document.getElementById('highlightModal')).hide();
    };

    window.clearHighlight = function() {
        highlightedNodeKeys = new Set();

        if (scopeCy) {
            scopeCy.nodes().removeClass('centrality-highlighted');
        }

        // Update dropdown button
        const btn = document.getElementById('highlightDropdown');
        btn.classList.remove('btn-warning');
        btn.classList.add('btn-outline-secondary');
        btn.textContent = 'Highlight...';

        // Dispatch event to sync with list view
        window.dispatchEvent(new CustomEvent('centrality-highlight-changed', {
            detail: { highlightedKeys: [], metric: null, threshold: 0 }
        }));
    };

    // Re-apply highlights after graph updates
    function reapplyHighlights() {
        if (scopeCy && highlightedNodeKeys.size > 0) {
            scopeCy.nodes().removeClass('centrality-highlighted');
            highlightedNodeKeys.forEach(nodeId => {
                const node = scopeCy.getElementById(nodeId);
                if (node && node.length > 0) {
                    node.addClass('centrality-highlighted');
                }
            });
        }
    }

    // Listen for updates from the scoping page
    window.addEventListener('scope-graph-update', function(e) {
        const { visibleKeys, selectedKeys } = e.detail;
        console.log('scope-graph-update received:', visibleKeys?.length, 'visible keys');

        // Initialize graph lazily (only when first needed and container is visible)
        if (!scopeCy) {
            console.log('Initializing scope graph...');
            initScopeGraph();
            console.log('scopeCy initialized:', !!scopeCy);
        }

        if (!visibleKeys || visibleKeys.length === 0) {
            console.log('No visible keys, clearing graph');
            if (scopeCy) {
                scopeCy.elements().remove();
                document.getElementById('scope-graph-count').textContent = '0';
            }
            // Clear cycle count in header
            window.dispatchEvent(new CustomEvent('scope-cycle-count', { detail: { count: 0 } }));
            return;
        }

        // Show loading overlay for large graphs (show early to give feedback)
        const loadingOverlay = document.getElementById('scope-loading-overlay');
        const loadingText = document.getElementById('scope-loading-text');
        if (visibleKeys.length > 100) {
            loadingOverlay.style.display = 'flex';
            loadingText.textContent = `Loading ${visibleKeys.length} nodes...`;
        }

        // Fetch graph data for visible keys
        const csrfToken = getCSRFToken();
        console.log('CSRF token:', csrfToken ? 'found' : 'NOT FOUND');

        fetch('/htmx/scope-graph/data/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrfToken
            },
            body: JSON.stringify({ keys: visibleKeys })
        })
            .then(r => r.json())
            .then(data => {
                console.log('Scope graph data:', data.nodes?.length, 'nodes,', data.edges?.length, 'edges');

                const nodeCount = data.nodes?.length || 0;
                if (nodeCount > 200) {
                    loadingText.textContent = `Rendering ${nodeCount} nodes...`;
                }

                // Break up work into chunks to keep UI responsive
                // Step 1: Clear existing elements
                setTimeout(() => {
                    scopeCy.elements().remove();

                    // Step 2: Add nodes (in batches for very large graphs)
                    setTimeout(() => {
                        if (nodeCount > 200) {
                            loadingText.textContent = `Adding ${nodeCount} nodes...`;
                        }

                        // Use batch mode for better performance
                        scopeCy.batch(() => {
                            scopeCy.add(data.nodes);
                        });

                        // Step 3: Add edges after nodes (defer for very large graphs)
                        setTimeout(() => {
                            // For very large graphs, defer edge addition until user requests
                            if (nodeCount > 1000) {
                                console.log('Deferring', data.edges?.length || 0, 'edges for performance');
                                deferredEdges = data.edges;
                                edgesDeferred = true;
                            } else {
                                if (nodeCount > 200) {
                                    loadingText.textContent = `Adding ${data.edges?.length || 0} edges...`;
                                }
                                scopeCy.batch(() => {
                                    scopeCy.add(data.edges);
                                });
                                deferredEdges = null;
                                edgesDeferred = false;
                            }
                            console.log('Elements added, total:', scopeCy.elements().length);

                            // Step 4: Layout and finalize
                            setTimeout(() => {
                                if (nodeCount > 200) {
                                    loadingText.textContent = `Laying out ${nodeCount} nodes...`;
                                }

                                // Resize to ensure container dimensions are correct
                                scopeCy.resize();

                                // Apply layout - use fast layout for large graphs
                                if (data.has_positions) {
                                    console.log('Using preset layout');
                                    scopeCy.layout({ name: 'preset', padding: 30 }).run();
                                } else if (nodeCount > 500) {
                                    // For large graphs, use fast grid layout
                                    console.log('Using grid layout for', nodeCount, 'nodes');
                                    scopeCy.layout({
                                        name: 'grid',
                                        animate: false,
                                        padding: 30,
                                        avoidOverlapPadding: 10,
                                        condense: true,
                                    }).run();
                                } else if (nodeCount > 100) {
                                    // For medium graphs, use concentric layout (faster than cose)
                                    console.log('Using concentric layout for', nodeCount, 'nodes');
                                    scopeCy.layout({
                                        name: 'concentric',
                                        animate: false,
                                        padding: 30,
                                        minNodeSpacing: 50,
                                    }).run();
                                } else {
                                    // For small graphs, use cose for nice layout
                                    console.log('Using cose layout for', nodeCount, 'nodes');
                                    scopeCy.layout({
                                        name: 'cose',
                                        animate: false,
                                        nodeRepulsion: 400000,
                                        idealEdgeLength: 100,
                                        edgeElasticity: 100,
                                        padding: 50,
                                        randomize: false,
                                    }).run();
                                }

                                scopeCy.fit(30);
                                console.log('After fit, zoom:', scopeCy.zoom(), 'pan:', scopeCy.pan());

                                // Update count
                                document.getElementById('scope-graph-count').textContent = data.nodes.length;

                                // Update cycle edge count (cycles loaded lazily)
                                const cycleEdgeCount = data.cycle_edge_count || 0;
                                const cyclesDropdownBtn = document.getElementById('scope-cycles-dropdown-btn');

                                currentVisibleKeys = visibleKeys;
                                cyclesLoaded = false;
                                currentCycles = [];

                                // Dispatch cycle count to header
                                window.dispatchEvent(new CustomEvent('scope-cycle-count', {
                                    detail: { count: cycleEdgeCount }
                                }));

                                if (cycleEdgeCount > 0) {
                                    cyclesDropdownBtn.style.display = 'inline-block';
                                    // Reset dropdown - will be populated on click
                                    document.getElementById('scope-cycles-list').innerHTML = '<li><a class="dropdown-item text-muted" href="#">Loading cycles...</a></li>';
                                } else {
                                    cyclesDropdownBtn.style.display = 'none';
                                }
                                shownCycleIndex = -1;

                                // Restore selection state
                                if (selectedKeys && selectedKeys.length > 0) {
                                    const selectedSet = new Set(selectedKeys);
                                    scopeCy.nodes().forEach(node => {
                                        if (selectedSet.has(node.id())) {
                                            node.select();
                                        }
                                    });
                                }

                                // For very large graphs, hide edges by default for performance
                                if (nodeCount > 500 || edgesDeferred) {
                                    scopeEdgesVisible = false;
                                    if (!edgesDeferred) {
                                        scopeCy.edges().hide();
                                    }
                                    document.getElementById('scope-toggle-edges-btn').classList.remove('active');
                                } else {
                                    // Restore visibility settings
                                    if (!scopeTransitiveVisible) {
                                        scopeCy.edges('[?transitive]').hide();
                                    }
                                }

                                // Re-apply centrality highlights
                                reapplyHighlights();

                                // Set up lazy loading for cycles dropdown
                                const cyclesDropdown = document.getElementById('scope-cycles-dropdown-btn');
                                if (cyclesDropdown) {
                                    cyclesDropdown.addEventListener('click', loadCyclesLazily, { once: true });
                                }

                                // Hide loading overlay
                                loadingOverlay.style.display = 'none';
                            }, 0); // Step 4: layout
                        }, 0); // Step 3: add edges
                    }, 0); // Step 2: add nodes
                }, 0); // Step 1: clear
            })
            .catch(err => {
                console.error('Scope graph fetch error:', err);
                loadingOverlay.style.display = 'none';
            });
    });

    // Expose functions globally
    window.scopeGraphToggleLabels = function() {
        if (!scopeCy) return;
        scopeLabelsVisible = !scopeLabelsVisible;
        const btn = document.getElementById('scope-toggle-labels-btn');
        if (scopeLabelsVisible) {
            scopeCy.style().selector('node').style('label', 'data(label)').update();
            btn.classList.add('active');
        } else {
            scopeCy.style().selector('node').style('label', '').update();
            btn.classList.remove('active');
        }
    };

    window.scopeGraphToggleEdges = function() {
        if (!scopeCy) return;
        scopeEdgesVisible = !scopeEdgesVisible;
        const btn = document.getElementById('scope-toggle-edges-btn');
        if (scopeEdgesVisible) {
            // Add deferred edges if they exist
            if (edgesDeferred && deferredEdges) {
                const loadingOverlay = document.getElementById('scope-loading-overlay');
                const loadingText = document.getElementById('scope-loading-text');
                loadingOverlay.style.display = 'flex';
                loadingText.textContent = `Adding ${deferredEdges.length} edges...`;

                setTimeout(() => {
                    scopeCy.batch(() => {
                        scopeCy.add(deferredEdges);
                    });
                    deferredEdges = null;
                    edgesDeferred = false;

                    // Apply visibility
                    if (!scopeTransitiveVisible) {
                        scopeCy.edges('[?transitive]').hide();
                    }
                    loadingOverlay.style.display = 'none';
                }, 0);
            } else {
                scopeCy.edges().show();
                // Re-apply transitive filter
                if (!scopeTransitiveVisible) {
                    scopeCy.edges('[?transitive]').hide();
                }
            }
            btn.classList.add('active');
        } else {
            scopeCy.edges().hide();
            btn.classList.remove('active');
        }
    };

    window.scopeGraphToggleTransitive = function() {
        if (!scopeCy) return;
        scopeTransitiveVisible = !scopeTransitiveVisible;
        const btn = document.getElementById('scope-toggle-transitive-btn');
        if (scopeTransitiveVisible) {
            if (scopeEdgesVisible) {
                scopeCy.edges('[?transitive]').show();
            }
            btn.classList.add('active');
        } else {
            scopeCy.edges('[?transitive]').hide();
            btn.classList.remove('active');
        }
    };

    window.scopeGraphToggleCycles = function() {
        if (!scopeCy) return;
        scopeCyclesVisible = !scopeCyclesVisible;
        const btn = document.getElementById('scope-toggle-cycles-btn');
        const cycleEdges = scopeCy.edges('[?inCycle]');

        if (scopeCyclesVisible) {
            cycleEdges.addClass('cycle-highlighted');
            cycleEdges.forEach(edge => {
                edge.source().addClass('cycle-highlighted');
                edge.target().addClass('cycle-highlighted');
            });
            btn.classList.add('active');
            btn.classList.remove('btn-outline-secondary');
            btn.classList.add('btn-danger');
        } else {
            cycleEdges.removeClass('cycle-highlighted');
            scopeCy.nodes().removeClass('cycle-highlighted');
            btn.classList.remove('active');
            btn.classList.remove('btn-danger');
            btn.classList.add('btn-outline-secondary');
        }
    };

    window.scopeGraphFit = function() {
        if (scopeCy) scopeCy.fit(30);
    };

    window.scopeGraphRelayout = function() {
        if (!scopeCy) return;
        scopeCy.layout({
            name: 'cose',
            animate: true,
            animationDuration: 800,
            nodeRepulsion: 400000,
            idealEdgeLength: 400,
            edgeElasticity: 400,
            padding: 100,
            randomize: true,
            componentSpacing: 200,
            nodeOverlap: 100,
        }).run();
    };

    // Lazy load cycles from backend
    function loadCyclesLazily() {
        if (cyclesLoaded || !currentVisibleKeys.length) return;

        const cyclesList = document.getElementById('scope-cycles-list');
        cyclesList.innerHTML = '<li><a class="dropdown-item text-muted" href="#"><span class="spinner-border spinner-border-sm me-2"></span>Loading...</a></li>';

        fetch('/htmx/scope-graph/cycles/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCSRFToken()
            },
            body: JSON.stringify({ keys: currentVisibleKeys })
        })
        .then(r => r.json())
        .then(data => {
            currentCycles = data.cycles || [];
            cyclesLoaded = true;

            // Log debug info
            if (data.debug) {
                console.log('Cycles debug:', JSON.stringify(data.debug, null, 2));
                if (data.debug.invalid_cycles && data.debug.invalid_cycles.length > 0) {
                    console.error('Invalid cycles found:', JSON.stringify(data.debug.invalid_cycles, null, 2));
                }
            }

            // Populate dropdown
            cyclesList.innerHTML = '<li><a class="dropdown-item" href="#" onclick="showAllCycles(); return false;"><strong>Show all cycles</strong></a></li>';
            if (currentCycles.length > 0) {
                cyclesList.innerHTML += '<li><hr class="dropdown-divider"></li>';
                currentCycles.forEach((cycle, idx) => {
                    const cycleLabel = cycle.map(n => n.split(':').pop().split('-')[0]).join(' → ');
                    const li = document.createElement('li');
                    li.innerHTML = `<a class="dropdown-item small" href="#" onclick="showSingleCycle(${idx}); return false;" title="${cycle.join(' → ')}"><span class="badge bg-secondary me-1">${cycle.length}</span>${cycleLabel}</a>`;
                    cyclesList.appendChild(li);
                });
            } else {
                cyclesList.innerHTML += '<li><a class="dropdown-item text-muted small" href="#">No individual cycles found</a></li>';
            }
        })
        .catch(err => {
            console.error('Failed to load cycles:', err);
            cyclesList.innerHTML = '<li><a class="dropdown-item text-danger" href="#">Failed to load cycles</a></li>';
        });
    }

    // Show all cycles (same as toggle button)
    window.showAllCycles = function() {
        if (!scopeCy) return;
        shownCycleIndex = -1;

        // If edges are deferred, add them first
        if (edgesDeferred && deferredEdges) {
            const loadingOverlay = document.getElementById('scope-loading-overlay');
            const loadingText = document.getElementById('scope-loading-text');
            loadingOverlay.style.display = 'flex';
            loadingText.textContent = `Adding ${deferredEdges.length} edges...`;

            setTimeout(() => {
                scopeCy.batch(() => {
                    scopeCy.add(deferredEdges);
                });
                deferredEdges = null;
                edgesDeferred = false;
                loadingOverlay.style.display = 'none';

                // Now show cycles
                doShowAllCycles();
            }, 0);
        } else {
            doShowAllCycles();
        }
    };

    function doShowAllCycles() {
        // Clear previous cycle marking
        scopeCy.elements().removeClass('cycle-highlighted single-cycle-highlighted');

        // Mark all cycle edges
        const cycleEdges = scopeCy.edges('[?inCycle]');
        cycleEdges.addClass('cycle-highlighted');
        cycleEdges.forEach(edge => {
            edge.source().addClass('cycle-highlighted');
            edge.target().addClass('cycle-highlighted');
        });

        // Update button state
        scopeCyclesVisible = true;
        const btn = document.getElementById('scope-toggle-cycles-btn');
        btn.classList.add('active', 'btn-danger');
        btn.classList.remove('btn-outline-secondary');
    }

    // Show a single cycle by index
    window.showSingleCycle = function(cycleIndex) {
        if (!scopeCy || !currentCycles[cycleIndex]) return;
        shownCycleIndex = cycleIndex;

        const cycle = currentCycles[cycleIndex];

        // If edges are deferred, add ALL edges first (they'll be hidden, but cycle edges will be shown)
        if (edgesDeferred && deferredEdges) {
            console.log('Adding all', deferredEdges.length, 'deferred edges before showing cycle');
            scopeCy.batch(() => {
                scopeCy.add(deferredEdges);
            });
            // Hide all edges initially (cycle edges will be shown below)
            scopeCy.edges().hide();
            deferredEdges = null;
            edgesDeferred = false;
        }

        // Clear all cycle marking
        scopeCy.elements().removeClass('cycle-highlighted single-cycle-highlighted');

        // Mark nodes in this cycle
        cycle.forEach(nodeId => {
            const node = scopeCy.getElementById(nodeId);
            if (node.length) {
                node.addClass('single-cycle-highlighted');
            }
        });

        // Mark edges in this cycle
        let foundEdges = 0;
        let missingEdges = [];
        for (let i = 0; i < cycle.length; i++) {
            const source = cycle[i];
            const target = cycle[(i + 1) % cycle.length];
            const edgeId = `${source}->${target}`;
            const edge = scopeCy.getElementById(edgeId);
            if (edge.length) {
                edge.addClass('single-cycle-highlighted');
                edge.show();  // Make sure edge is visible
                foundEdges++;
            } else {
                missingEdges.push(edgeId);
            }
        }
        if (missingEdges.length > 0) {
            console.warn('Cycle missing edges in graph:', JSON.stringify(missingEdges));
            console.warn('Found ' + foundEdges + '/' + cycle.length + ' edges. Total edges in graph: ' + scopeCy.edges().length);
        }

        // Arrange cycle nodes in a circle (in cycle order) for better visualization
        const markedNodes = scopeCy.nodes('.single-cycle-highlighted');
        if (markedNodes.length > 0) {
            // Get center of marked nodes
            const bbox = markedNodes.boundingBox();
            const centerX = (bbox.x1 + bbox.x2) / 2;
            const centerY = (bbox.y1 + bbox.y2) / 2;
            const radius = Math.max(100, cycle.length * 40);

            // Arrange in a circle following cycle order
            cycle.forEach((nodeId, i) => {
                const node = scopeCy.getElementById(nodeId);
                if (node.length) {
                    const angle = (2 * Math.PI * i) / cycle.length - Math.PI / 2;
                    node.position({
                        x: centerX + radius * Math.cos(angle),
                        y: centerY + radius * Math.sin(angle)
                    });
                }
            });
        }

        // Fit view to marked elements
        const marked = scopeCy.elements('.single-cycle-highlighted');
        if (marked.length > 0) {
            scopeCy.fit(marked, 50);
        }

        // Update button state
        scopeCyclesVisible = true;
        const btn = document.getElementById('scope-toggle-cycles-btn');
        btn.classList.add('active', 'btn-warning');
        btn.classList.remove('btn-outline-secondary', 'btn-danger');
    };
})();
</script>
